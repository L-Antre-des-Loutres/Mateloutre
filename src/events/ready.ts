import {
  Events,
  ChannelType,
  PermissionFlagsBits,
  Colors,
  Client,
  Guild,
  TextChannel,
  EmbedBuilder,
  ColorResolvable
} from "discord.js";
import * as fs from "fs";
import * as path from "path";
import { BotEvent } from "../types";
import otterlogs from "../utils/otterlogs";
import {fetchPokeNews} from "../scraper/pokeNewsScraper";

const CACHE_FILE = path.join(__dirname, '../../pokekalos-latest-news.cache');

const event: BotEvent = {
  name: Events.ClientReady,
  once: true,
  async execute(client: Client) {
    otterlogs.success(`Ready! Logged in as ${client.user?.tag}`);
    client.user?.setActivity("Who's that Pok√©mon?!");

    // Noms des salons √† cr√©er pour le fonctionnement de mineotter
    const channelNames: string[] = [
      "ü¶¶„Éªlogs-mateloutre",
      "‚ùå„Éªlogs-erreur"
    ];

    // ID du serveur
    const guildId = process.env.GUILD_ID;
    if (!guildId) {
      otterlogs.error("GuildId non trouv√©e");
      return;
    }

    // Nom de la cat√©gorie
    const categoryName = process.env.CATEGORY_NAME;
    if (!categoryName) {
      otterlogs.error("CategoryName non trouv√©e");
      return;
    }

    // Nom du r√¥le
    const roleName = process.env.ROLE_NAME;
    if (!roleName) {
      otterlogs.error("RoleName non trouv√©e");
      return;
    }

    // Tableau pour stocker les noms des salons existants
    const channelsDiscord: string[] = [];

    try {
      // R√©cup√®re la guild
      const guild: Guild | undefined = client.guilds.cache.get(guildId);
      if (!guild) {
        otterlogs.error("Guild non trouv√©e");
        return;
      }

      // R√©cup√®re la liste des salons et stocke les noms dans un tableau
      guild.channels.cache.forEach((channel) => {
        channelsDiscord.push(channel.name);
      });

      // V√©rifie si le r√¥le existe d√©j√†
      let role = guild.roles.cache.find((r) => r.name === roleName);
      if (!role) {
        // Cr√©e un r√¥le sp√©cifique
        role = await guild.roles.create({
          name: roleName,
          color: Colors.Blue,
          reason: "Role sp√©cifique pour la cat√©gorie",
        });
        otterlogs.success(`R√¥le "${roleName}" cr√©√© !`);
      } else {
        otterlogs.log(`Le r√¥le "${roleName}" existe d√©j√†`);
      }

      // V√©rifie si la cat√©gorie existe d√©j√†
      let category = guild.channels.cache.find(
        (channel) =>
          channel.name === categoryName &&
          channel.type === ChannelType.GuildCategory
      );

      if (category) {
        otterlogs.log(`La cat√©gorie "${categoryName}" existe d√©j√†`);
      } else {
        // Cr√©e une cat√©gorie avec les permissions pour le r√¥le sp√©cifique
        category = await guild.channels.create({
          name: categoryName,
          type: ChannelType.GuildCategory,
          permissionOverwrites: [
            {
              id: guild.id, // ID du serveur
              deny: [PermissionFlagsBits.ViewChannel], // Interdire la vue des salons √† tout le monde par d√©faut
            },
            {
              id: role.id, // ID du r√¥le sp√©cifique
              allow: [PermissionFlagsBits.ViewChannel], // Autoriser la vue des salons pour le r√¥le sp√©cifique
            },
          ],
        });
        otterlogs.success(`Cat√©gorie "${categoryName}" cr√©√©e avec les permissions !`);
      }

      // Cr√©e des salons √† l'int√©rieur de la cat√©gorie avec les m√™mes permissions
      for (const channelName of channelNames) {
        if (channelsDiscord.includes(channelName)) {
          otterlogs.log(`Le salon "${channelName}" existe d√©j√†`);
        } else {
          await guild.channels.create({
            name: channelName,
            type: ChannelType.GuildText,
            parent: category.id,
            permissionOverwrites: [
              {
                id: guild.id,
                deny: [PermissionFlagsBits.ViewChannel],
              },
              {
                id: role.id,
                allow: [PermissionFlagsBits.ViewChannel],
              },
            ],
          });
          otterlogs.success(`Salon "${channelName}" cr√©√© !`);
        }
      }
    } catch (error) {
      otterlogs.error(`Erreur lors de la cr√©ation de la cat√©gorie, des salons et du r√¥le : ${error}`);
    }

    // Appel imm√©diat au d√©marrage
    await (async () => {
      try {
        await scrape();
      } catch (err) {
        console.error("‚ùå Erreur initiale du scraping :", err);
      }
    })();

    setInterval(async () => {
      await scrape();
    }, 1000 * 60 * 30); // toutes les 30 minutes

    // Fonction de scraping
    async function scrape() {
      otterlogs.log("Lancement du scraping des actus de Pokekalos.");
      try {
        const news = await fetchPokeNews();

        // Supposons que news[0] est un objet Cheerio ou contient un champ 'html'
        console.log(news); // ou console.log(news[0].html) selon structure

        if (!news.length) return;

        const latest = news[0];
        const lastTitle = fs.existsSync(CACHE_FILE) ? fs.readFileSync(CACHE_FILE, 'utf-8') : '';

        if (latest.title !== lastTitle) {
          fs.writeFileSync(CACHE_FILE, latest.title);

          const message = `üóíÔ∏è Une nouvelle actualit√© Pok√©mon est en ligne sur Pok√©kalos.`;
          const embed : EmbedBuilder = new EmbedBuilder()
          .setTitle(latest.title).setURL(latest.link)
              .setDescription(`${latest.description}\nüîó [Lire l'article](${latest.link})`)
              .setImage(latest.image)
              .setColor(process.env.BOT_COLOR as ColorResolvable)
              .setFields(
                  {name: 'Source', value: 'Pokekalos', inline: true},
                  {name: 'Date', value: latest.date, inline: true}
              )
              .setFooter({
                text: "Mineotter",
                iconURL: client.user?.displayAvatarURL() || '',
              })
          .setTimestamp();
          const channel = client.channels.cache.get(process.env.NEWS_CHANNEL_ID) as TextChannel;
          await channel.send({content: message, embeds: [embed]});
          console.log(`‚úÖ Nouvelle actu envoy√©e : ${latest.title}`);
        } else {
          console.log('‚úÖ Aucune nouvelle actu.');
        }
      } catch (error) {
        console.error("Erreur lors du scraping :", error);
      }
    }
  }
};

export default event;
